
#
# root object
#
class @os {
  @lstring name
  @typeDeclarationMap      typeDeclarations
  @varDeclarationMap       varDeclarations
  @funcDeclarationMap      funcDeclarations
  @schedulerDeclarationMap schedulerDeclarations
  @transDeclarationMap     transDeclarations
  @backendDeclarationMap   backendDeclarations
}

map @typeDeclarationMap {
  @typeDeclaration type
  insert putType error message "Type '%K' is already declared in %L"
  search getType error message "Type '%K' is not declared"
  insert putTaskType error message "Task type '%K' is already declared in %L"
  search getTaskType error message "Task type '%K' is not declared"
  insert putCpuType error message "CPU type '%K' is already declared in %L"
  search getCpuType error message "CPU type '%K' is not declared"
}

map @varDeclarationMap {
  @varDeclaration variable
  insert putData error message "Data '%K' is already declared in %L"
  search getData error message "Data '%K' is not declared"
  insert putField error message "Field '%K' is already declared in %L"
  search getField error message "Field '%K' is not declared"
  search getTimer error message "Timer '%K' is not declared"
}

map @schedulerDeclarationMap {
  @schedulerDeclaration scheduler
  insert putScheduler error message "Scheduler '%K' is already declared in %L"
  search getScheduler error message "Scheduler '%K' is not declared"
}

map @transDeclarationMap {
  @transDeclaration transition
  insert putTrans error message "Transitions '%K' are already declared in %L"
  search getTrans error message "Transitions '%K' are not declared"
}

map @apiDeclarationMap {
  @apiDeclaration api
  insert putApi error message "API '%K' are already declared in %L"
  search getApi error message "API '%K' are not declared"
}

getter @typeDeclarationMap hasLKey ?let @lstring lkey -> @bool result{
  result = [self hasKey ![lkey string]]
}

abstract class @typeDeclaration {
  @lstring name
  @varDeclarationMap fields
}

class @normalTypeDeclaration : @typeDeclaration {}

abstract class @specialTypeDeclaration : @typeDeclaration {}

class @taskDeclaration : @specialTypeDeclaration {
  @transitionList allowed
  @lstring father
  @lstringmap states
}

#---------------------------------------------------------------------------*
# get all the states of a task, including the states defined by the
# ancestors
#
getter @taskDeclaration allStates
  ?let @os os
  ->@lstringmap result
{
  if [father string] != "" then
    @typeDeclaration refobj
    [[os typeDeclarations] getTaskType !father ?refobj]
    cast refobj
    case == @taskDeclaration fatherTask :
      result = @lstringmap.mapWithMapToOverride {![fatherTask allStates !os]}
      for () in  states do
        [!?result putState !lkey]
      end
    else
      error father: " wrong type" : result
    end
  else
    result = states
  end
}

class @cpuDeclaration :  @specialTypeDeclaration {
  @transitionList allowed
  @lstring task
  @acceptMap states
}

class @schedulerDeclaration {
  @lstring name
  @lstring task
  @lstring cpu
  @varDeclarationMap locals
  @methodDeclarationMap methods
}

class @methodDeclaration {
  @lstring name
  @argumentList arguments
  @varDeclarationMap locals
  @statementList statements
}

map @methodDeclarationMap {
  @methodDeclaration methodDeclaration
  insert putMethod error message "Method '%K' is already declared in %L"
  search getMethod error message "Method '%K' is not declared"
}

class @transDeclaration {
  @lstring name
  @lstring taskType
  @lstring taskName
  @transitionList transitions
}

map @errorDeclarationMap {
  @errorList errors
  insert putError error message "Error set '%K' is already declared in %L"
  search getError error message "Error set '%K' is not declared"
}

list @errorList {
  @lstring name
  @bool    valueSet
  @luint64 value
}

class @apiDeclaration {
  @lstring name
  @lstring scheduler
  @serviceList services
}
  

list @serviceList {
  @service service
}

class @service {
  @lstring name
  @argumentList arguments
  @varDeclarationMap locals
  @checkList assumes
  @statementList statements
}

list @checkList {
  @check check
}

class @check {
  @expression good
  @lstring errorCode
}

class @funcDeclaration {
  @lstring name
  @sdmlType type
  @argumentList arguments
  @varDeclarationMap locals
  @statementList statements
}

map @funcDeclarationMap {
  @funcDeclaration function
  insert putFunction error message "Function '%K' is already declared in %L"
  search getFunction error message "Function '%K' is not declared"
}

class @accessRight {
  @location location
  @bool read
  @bool write
  @bool constant
}

func rwAccess ->@accessRight access {
  access = @accessRight.new {!.here !true !true !false}
}

func roAccess ->@accessRight access {
  access = @accessRight.new {!.here !true !false !false}
}

abstract class @varDeclaration {
  @lstring name
  @sdmlType type
}

class @builtInVar :  @varDeclaration {
  @accessRight access
}

class @refVar :  @builtInVar {}

class @containerVar :  @refVar {
  @lstringmap states
  @orderingList ordering
}

class @sdmlContainerVar : @refVar {
  @lstringmap states
  @sdmlOrderingList ordering
}

abstract class @acceptStatement {
  @lstring cpuState
}

class @emptyAcceptStatement : @acceptStatement {
}

class @taskAcceptStatement : @acceptStatement {
  @lstring taskState
}

map @acceptMap {
  @acceptStatement accept
  insert putState error message "state '%K' is already declared in %L"
  search getState error message "state '%K' is not declared"
}

map @lstringmap {
  insert putState error message "state '%K' is already declared in %L"
  search getState error message "state '%K' is not declared"
  insert putCpuOrTask error message "object '%K' is already declared in %L"
  search getCpuOrTask error message "object '%K' is not declared"
}

getter @lstringmap hasLKey ?let @lstring lkey ->@bool result{
  result = [self hasKey ![lkey string]]
}

getter @acceptMap hasLKey ?let @lstring lkey ->@bool result{
  result = [self hasKey ![lkey string]]
}

abstract class @migrationDestination { @location loc }
abstract method @migrationDestination checkSource
  ?let @os os
  ?let @lstringlist source

class @containerDestination :  @migrationDestination { @lstringlist container @lbool position }
override method @containerDestination checkSource
  ?let @os os
  ?let @lstringlist source
{
  @sdmlType sourceType = [[os varDeclarations] identifierType !source !os]
   # destination must be the same type or inherit from the type
  @lstringlist destinationType = [[os varDeclarations] identifierTypeList !container !os]
  if not [destinationType mayContain ![sourceType lTypeName]] then
    error loc: "destination type does not match source type"
  end
}

class @stateDestination : @migrationDestination {
  @lstring taskState
}
override method @stateDestination checkSource
  ?let @os os
  ?let @lstringlist source
{
  if [taskState string] != "" then
    @sdmlType sourceType = [[os varDeclarations] identifierType !source !os]
    @typeDeclaration taskType
    [[os typeDeclarations] getTaskType ![sourceType lTypeName] ?taskType] 
    cast taskType
    case == @taskDeclaration td :
      @lstringmap states = [td allStates !os]
      if not [states hasLKey !taskState] then
        error taskState: "state of the source expected"
      end
    else
      @lstring last
      [source last ?last]
      error last: "task type expected"
    end
  end
}

#enum @exprType {
#  unsignedType, integerType, boolType, timerType, customType
#}{}

#class @fullType {
#  @exprType type
#  @lstring customType
#  @bool collection
#}

#getter @exprType string -> @string result:
#  switch self
#  when unsignedType: result = "unsigned"
#  when integerType:  result = "int"
#  when boolType:     result = "bool"
#  when timerType:    result = "timer"
#  when customType:   result = "custom"
#  end switch
#end

list @orderingList {
  @expression key
  @bool       up
}

list @sdmlOrderingList {
  @sdmlExpression key
  @bool           up
}

abstract class @sdmlExpression { @location loc @sdmlType type }
class @sdmlValidNode        : @sdmlExpression { @lstring identifier }
class @sdmlEmptyNode        : @sdmlExpression { @lstringlist identifier }
abstract class @sdmlUniNode : @sdmlExpression { @sdmlExpression expressionValue }
abstract class @sdmlBinNode : @sdmlExpression { @sdmlExpression left @sdmlExpression right }
class @sdmlFunctionCallNode : @sdmlExpression { @lstring funcName @sdmlExpressionList arguments }
class @sdmlIntegerNode      : @sdmlExpression { @luint64 integerValue }
class @sdmlBoolNode         : @sdmlExpression { @lbool boolValue }
class @sdmlIdentifierNode   : @sdmlExpression { @lstringlist identifierValue }
class @sdmlMinNode          : @sdmlExpression { @lstringlist field @lstringlist container }
class @sdmlMaxNode          : @sdmlExpression { @lstringlist field @lstringlist container }
class @sdmlSubExprNode      : @sdmlUniNode {}
class @sdmlNotNode          : @sdmlUniNode {}
class @sdmlCompNode         : @sdmlUniNode {}
class @sdmlEqualNode        : @sdmlBinNode {}
class @sdmlDifferNode       : @sdmlBinNode {}
class @sdmlLowerEqualNode   : @sdmlBinNode {}
class @sdmlGreaterEqualNode : @sdmlBinNode {}
class @sdmlLowerNode        : @sdmlBinNode {}
class @sdmlGreaterNode      : @sdmlBinNode {}
class @sdmlAndNode          : @sdmlBinNode {}
class @sdmlOrNode           : @sdmlBinNode {}
class @sdmlXorNode          : @sdmlBinNode {}
class @sdmlShiftLeftNode    : @sdmlBinNode {}
class @sdmlShiftRightNode   : @sdmlBinNode {}
class @sdmlAndAndNode       : @sdmlBinNode {}
class @sdmlOrOrNode         : @sdmlBinNode {}
class @sdmlAddNode          : @sdmlBinNode {}
class @sdmlSubNode          : @sdmlBinNode {}
class @sdmlMulNode          : @sdmlBinNode {}
class @sdmlDivNode          : @sdmlBinNode {}
class @sdmlRemainNode       : @sdmlBinNode {}

list @sdmlExpressionList {
  @sdmlExpression expr
}

list @sdmlTypeList {
  @sdmlType type
}

#
# getters to build a sdmlExpression from an expression
# The getter compute the type
#
abstract getter @expression sdmlExpression
  ?let @os os
  ->@sdmlExpression #outExpr

method @binNode binSameType
  ?let @os os
  ?let @string operatorString
  !@sdmlExpression leftExpr
  !@sdmlExpression rightExpr
{
  leftExpr = [left sdmlExpression !os]
  rightExpr = [right sdmlExpression !os]
  if not [[leftExpr type] isEqualTo ![rightExpr type]] then
    error loc: operatorString + " operator expects the same left and right expression types"
  end
}

method @binNode binSameTypeAndNumber
  ?let @os os
  ?let @string operatorString
  !@sdmlExpression leftExpr
  !@sdmlExpression rightExpr
{
  leftExpr = [left sdmlExpression !os]
  rightExpr = [right sdmlExpression !os]
  if [[leftExpr type] dynamicType] == `@sdmlUnsigned | [[leftExpr type] dynamicType] == `@sdmlInteger then
    if not [[leftExpr type] isEqualTo ![rightExpr type]] then
      error loc: operatorString + " operator expects the same left and right expression types"
    end
  else
    error loc: operatorString + " operator expects integers or unsigned expression types"
  end
}

method @binNode binSameTypeAndNumberAndUnsigned
  ?let @os os
  ?let @string operatorString
  !@sdmlExpression leftExpr
  !@sdmlExpression rightExpr
{
  leftExpr = [left sdmlExpression !os]
  rightExpr = [right sdmlExpression !os]
  if [[leftExpr type] dynamicType] == `@sdmlUnsigned | [[leftExpr type] dynamicType] == `@sdmlInteger then
    if [[rightExpr type] dynamicType] != `@sdmlUnsigned then
      error loc: operatorString + " operator expects an unsigned right operand expression"
    end
  else
    error loc: operatorString + " operator expects integers or unsigned left operand expression"
  end
}

method @binNode binBoolean
  ?let @os os
  ?let @string operatorString
  !@sdmlExpression leftExpr
  !@sdmlExpression rightExpr
{
  leftExpr = [left sdmlExpression !os]
  rightExpr = [right sdmlExpression !os]
  if [[leftExpr type] dynamicType] == `@sdmlBool then
    if not [[rightExpr type] isEqualTo ![leftExpr type]] then
      error loc: operatorString + " operator expects boolean operand expressions"
    end
  else
    error loc: operatorString + " operator expects boolean operand expressions"
  end
}

override getter @validNode sdmlExpression
  ?let @os unused os
  ->@sdmlExpression outExpr
{
  outExpr = @sdmlValidNode.new { !loc !@sdmlBool.new {} !identifier }
}

override getter @emptyNode sdmlExpression
  ?let @os unused os
  ->@sdmlExpression outExpr
{
  outExpr = @sdmlEmptyNode.new { !loc !@sdmlBool.new {} !identifier }
}

override getter @integerNode sdmlExpression
  ?let @os unused os
  ->@sdmlExpression outExpr
{
  outExpr = @sdmlIntegerNode.new {!loc !@sdmlUnsigned.new{} !integerValue}
}

override getter @boolNode sdmlExpression
  ?let @os unused os
  ->@sdmlExpression outExpr
{
  outExpr = @sdmlBoolNode.new {!loc !@sdmlBool.new{} !boolValue}
}

override getter @identifierNode sdmlExpression
  ?let @os os
  ->@sdmlExpression outExpr
{
  @sdmlType identType = [[os varDeclarations] identifierType !identifierValue !os]
  outExpr = @sdmlIdentifierNode.new {!loc !identType !identifierValue}
}

override getter @minNode sdmlExpression
  ?let @os os
  ->@sdmlExpression outExpr
{
  @sdmlType containerType = [[os varDeclarations] identifierType !container !os]
  if [containerType isCollection] then
    @sdmlType itemType = [containerType itemType !os]
    @typeDeclaration itemTypeDeclaration
    [[os typeDeclarations] getType ![itemType lTypeName] ?itemTypeDeclaration]
    @sdmlType fieldType = [itemTypeDeclaration fieldType !os !field]
    if not [fieldType isOrdered] then
      @lstring last
      [field last ?last]
      error last : "Field is not of an ordered type" : outExpr
    else
      outExpr = @sdmlMinNode.new {!loc !fieldType !field !container}
    end
  else
    error [container location]: [container string]+" is not a container": outExpr
  end 
}

override getter @maxNode sdmlExpression
  ?let @os os
  ->@sdmlExpression outExpr
{
  @sdmlType containerType = [[os varDeclarations] identifierType !container !os]
  if [containerType isCollection] then
    @sdmlType itemType = [containerType itemType !os]
    @typeDeclaration itemTypeDeclaration
    [[os typeDeclarations] getType ![itemType lTypeName] ?itemTypeDeclaration]
    @sdmlType fieldType = [itemTypeDeclaration fieldType !os !field]
    if not [fieldType isOrdered] then
      @lstring last
      [field last ?last]
      error last : "Field is not of an ordered type" : outExpr
    else
      outExpr = @sdmlMaxNode.new {!loc !fieldType !field !container}
    end
  else
    error [container location]: [container string]+" is not a container": outExpr
  end 
}

override getter @subExprNode sdmlExpression
  ?let @os os
  ->@sdmlExpression outExpr
{
  @sdmlExpression subExpr = [expressionValue sdmlExpression !os]
  outExpr = @sdmlSubExprNode.new {!loc ![subExpr type] !subExpr}
}

override getter @notNode sdmlExpression
  ?let @os os
  ->@sdmlExpression outExpr
{
  @sdmlExpression expr = [expressionValue sdmlExpression !os]
  if [[expr type] dynamicType] == `@sdmlBool then
    outExpr = @sdmlNotNode.new {!loc ![expr type] !expr}
  else
    error loc: "'!' operator expects a bool expression":outExpr
  end
}

override getter @compNode sdmlExpression
  ?let @os os
  ->@sdmlExpression outExpr
{
  @sdmlExpression expr = [expressionValue sdmlExpression !os]
  if [[expr type] dynamicType] == `@sdmlUnsigned then
    outExpr = @sdmlCompNode.new{!loc ![expr type] !expr}
  else
    error loc: "'~' operator expects an unsigned expression":outExpr
  end
}

#override getter @emptyNode sdmlExpression
#  ??@scheduler scheduler
#  ??@dataMap data
#  ->@sdmlExpression outExpr
#:
#  @exprType containerType = findIdentifierType[!identifier !scheduler !data]
#  if containerType == [@exprType processType] then
#    outExpr = [@sdmlEmptyNode new !loc ![@exprType boolType] !identifier]
#  else
#    error loc: "process variable expected for empty built-in function": outExpr
#  end
#end
#
override getter @equalNode sdmlExpression
  ?let @os os
  ->@sdmlExpression outExpr
{
  @sdmlExpression leftExpr
  @sdmlExpression rightExpr
  [self binSameType !os !"'=='" ?leftExpr ?rightExpr]
  outExpr = @sdmlEqualNode.new {!loc !@sdmlBool.new{} !leftExpr !rightExpr}
}

override getter @differNode sdmlExpression
  ?let @os os
  ->@sdmlExpression outExpr
{
  @sdmlExpression leftExpr
  @sdmlExpression rightExpr
  [self binSameType !os !"'!='" ?leftExpr ?rightExpr]
  outExpr = @sdmlDifferNode.new {!loc !@sdmlBool.new{} !leftExpr !rightExpr}
}

override getter @lowerEqualNode sdmlExpression
  ?let @os os
  ->@sdmlExpression outExpr
{
  @sdmlExpression leftExpr
  @sdmlExpression rightExpr
  [self binSameTypeAndNumber !os !"'<='" ?leftExpr ?rightExpr]
  outExpr = @sdmlLowerEqualNode.new {!loc !@sdmlBool.new{} !leftExpr !rightExpr}
}

override getter @greaterEqualNode sdmlExpression
  ?let @os os
  ->@sdmlExpression outExpr
{
  @sdmlExpression leftExpr
  @sdmlExpression rightExpr
  [self binSameTypeAndNumber !os !"'>='" ?leftExpr ?rightExpr]
  outExpr = @sdmlGreaterEqualNode.new {!loc !@sdmlBool.new{} !leftExpr !rightExpr}
}

override getter @lowerNode sdmlExpression
  ?let @os os
  ->@sdmlExpression outExpr
{
  @sdmlExpression leftExpr
  @sdmlExpression rightExpr
  [self binSameTypeAndNumber !os !"'<'" ?leftExpr ?rightExpr]
  outExpr = @sdmlLowerNode.new {!loc !@sdmlBool.new{} !leftExpr !rightExpr}
}

override getter @greaterNode sdmlExpression
  ?let @os os
  ->@sdmlExpression outExpr
{
  @sdmlExpression leftExpr
  @sdmlExpression rightExpr
  [self binSameTypeAndNumber !os !"'>'" ?leftExpr ?rightExpr]
  outExpr = @sdmlGreaterNode.new {!loc !@sdmlBool.new{} !leftExpr !rightExpr}
}

override getter @andNode sdmlExpression
  ?let @os os
  ->@sdmlExpression outExpr
{
  @sdmlExpression leftExpr
  @sdmlExpression rightExpr
  [self binSameTypeAndNumber !os !"'&'" ?leftExpr ?rightExpr]
  outExpr = @sdmlAndNode.new {!loc ![leftExpr type] !leftExpr !rightExpr}
}

override getter @orNode sdmlExpression
  ?let @os os
  ->@sdmlExpression outExpr
{
  @sdmlExpression leftExpr
  @sdmlExpression rightExpr
  [self binSameTypeAndNumber !os !"'|'" ?leftExpr ?rightExpr]
  outExpr = @sdmlOrNode.new {!loc ![leftExpr type] !leftExpr !rightExpr}
}

override getter @xorNode sdmlExpression
  ?let @os os
  ->@sdmlExpression outExpr
{
  @sdmlExpression leftExpr
  @sdmlExpression rightExpr
  [self binSameTypeAndNumber !os !"'^'" ?leftExpr ?rightExpr]
  outExpr = @sdmlXorNode.new {!loc ![leftExpr type] !leftExpr !rightExpr}
}

override getter @shiftLeftNode sdmlExpression
  ?let @os os
  ->@sdmlExpression outExpr
{
  @sdmlExpression leftExpr
  @sdmlExpression rightExpr
  [self binSameTypeAndNumberAndUnsigned !os !"'<<'" ?leftExpr ?rightExpr]
  outExpr = @sdmlShiftLeftNode.new{!loc ![leftExpr type] !leftExpr !rightExpr}
}

override getter @shiftRightNode sdmlExpression
  ?let @os os
  ->@sdmlExpression outExpr
{
  @sdmlExpression leftExpr
  @sdmlExpression rightExpr
  [self binSameTypeAndNumberAndUnsigned !os !"'<<'" ?leftExpr ?rightExpr]
  outExpr = @sdmlShiftRightNode.new{!loc ![leftExpr type] !leftExpr !rightExpr}
}

override getter @andAndNode sdmlExpression
  ?let @os os
  ->@sdmlExpression outExpr
{
  @sdmlExpression leftExpr
  @sdmlExpression rightExpr
  [self binBoolean !os !"'&&'" ?leftExpr ?rightExpr]
  outExpr = @sdmlAndAndNode.new{!loc ![leftExpr type] !leftExpr !rightExpr}
}

override getter @orOrNode sdmlExpression
  ?let @os os
  ->@sdmlExpression outExpr
{
  @sdmlExpression leftExpr
  @sdmlExpression rightExpr
  [self binBoolean !os !"'||'" ?leftExpr ?rightExpr]
  outExpr = @sdmlOrOrNode.new{!loc ![leftExpr type] !leftExpr !rightExpr}
}

override getter @addNode sdmlExpression
  ?let @os os
  ->@sdmlExpression outExpr
{
  @sdmlExpression leftExpr
  @sdmlExpression rightExpr
  [self binSameTypeAndNumber !os !"'+'" ?leftExpr ?rightExpr]
  outExpr = @sdmlAddNode.new{!loc ![leftExpr type] !leftExpr !rightExpr}
}

override getter @subNode sdmlExpression
  ?let @os os
  ->@sdmlExpression outExpr
{
  @sdmlExpression leftExpr
  @sdmlExpression rightExpr
  [self binSameTypeAndNumber !os !"'-'" ?leftExpr ?rightExpr]
  outExpr = @sdmlSubNode.new{!loc ![leftExpr type] !leftExpr !rightExpr}
}

override getter @mulNode sdmlExpression
  ?let @os os
  ->@sdmlExpression outExpr
{
  @sdmlExpression leftExpr
  @sdmlExpression rightExpr
  [self binSameTypeAndNumber !os !"'*'" ?leftExpr ?rightExpr]
  outExpr = @sdmlMulNode.new{!loc ![leftExpr type] !leftExpr !rightExpr}
}

override getter @divNode sdmlExpression
  ?let @os os
  ->@sdmlExpression outExpr
{
  @sdmlExpression leftExpr
  @sdmlExpression rightExpr
  [self binSameTypeAndNumber !os !"'+'" ?leftExpr ?rightExpr]
  outExpr = @sdmlDivNode.new{!loc ![leftExpr type] !leftExpr !rightExpr}
}

override getter @remainNode sdmlExpression
  ?let @os os
  ->@sdmlExpression outExpr
{
  @sdmlExpression leftExpr
  @sdmlExpression rightExpr
  [self binSameTypeAndNumber !os !"'%'" ?leftExpr ?rightExpr]
  outExpr = @sdmlRemainNode.new{!loc ![leftExpr type] !leftExpr !rightExpr}
}

override getter @functionCallNode sdmlExpression
  ?let @os os
  ->@sdmlExpression outExpr
{
  @sdmlExpressionList args = .emptyList
  # get the function declaration for the return type
  @funcDeclaration declaration
  [[os funcDeclarations] getFunction !funcName ?declaration]
  # check the arguments
  for () in [declaration arguments], () in  arguments do
    # get the type of the actual argument
    @sdmlExpression actualArgument = [exp sdmlExpression !os]
    if not [[actualArgument type] isEqualTo !type] then
      error [actualArgument loc]: [type typeName]+" expected, got "+[[actualArgument type] typeName]
    end
    args += !actualArgument
  end
  outExpr = @sdmlFunctionCallNode.new{!loc ![declaration type] !funcName !args}
}


abstract class @assignStatement : @statement { @lstringlist identifier }
class @moveFrontStatement : @assignStatement { @lstringlist destination }
class @moveBackStatement : @assignStatement { @lstringlist source }
class @assignExpressionStatement : @assignStatement { @expression rightValue }
class @assignAddStatement : @assignExpressionStatement {}
class @assignSubStatement : @assignExpressionStatement {}
class @assignMulStatement : @assignExpressionStatement {}
class @assignDivStatement : @assignExpressionStatement {}
class @assignRemainStatement : @assignExpressionStatement {}
class @assignAndStatement : @assignExpressionStatement {}
class @assignOrStatement : @assignExpressionStatement {}
class @assignShiftLeftStatement : @assignExpressionStatement {}
class @assignShiftRightStatement : @assignExpressionStatement {}
class @assignIncStatement : @assignStatement {}
class @assignDecStatement : @assignStatement {}
class @schedulerMethodStatement : @statement { @lstring scheduler @lstring methodName @argumentCallList arguments }
class @functionCallStatement : @statement { @lstring funcName @expressionList arguments }
class @ifStatement : @statement { @expression condition @statementList trueStatements @statementList falseStatements }
class @moveStatement : @statement { @lstringlist source @migrationDestination destination }
class @startStatement : @statement { @lstringlist timer @expression delay @bool periodic @lstringlist methodName }
class @foreachStatement : @statement { @itemAndContainerList iteration @statementList statements}
class @moveeachStatement : @statement { @lstringlist srcItem @lstringlist srcContainer @migrationDestination destination @expression whileCondition }
class @moveeacheachStatement : @statement { @lstringlist srcItem @lstringlist srcContainer @lstring dstItem @lstringlist dstContainer @expression whileCondition }
class @moveOutStatement : @assignStatement { @lstring nextState }

list @itemAndContainerList {
  @lstring item
  @lstringlist container
  @expression where
}

list @transitionList {
  @lstring sourceState
  @lstring destinationState
  @statementList statements
}

#-----------------------------------------------------------------------------
# sdml statements
#-----------------------------------------------------------------------------
abstract class @sdmlStatement : @statement {}
abstract class @sdmlAssignStatement : @sdmlStatement { @lstringlist identifier }
class @sdmlAssignExpressionStatement : @sdmlAssignStatement { @sdmlExpression rightValue }
class @sdmlAssignAddStatement : @sdmlAssignExpressionStatement {}
class @sdmlAssignSubStatement : @sdmlAssignExpressionStatement {}
class @sdmlAssignMulStatement : @sdmlAssignExpressionStatement {}
class @sdmlAssignDivStatement : @sdmlAssignExpressionStatement {}
class @sdmlAssignRemainStatement : @sdmlAssignExpressionStatement {}
class @sdmlAssignAndStatement : @sdmlAssignExpressionStatement {}
class @sdmlAssignOrStatement : @sdmlAssignExpressionStatement {}
class @sdmlAssignShiftLeftStatement : @sdmlAssignExpressionStatement {}
class @sdmlAssignShiftRightStatement : @sdmlAssignExpressionStatement {}
class @sdmlAssignIncStatement : @sdmlAssignStatement {}
class @sdmlAssignDecStatement : @sdmlAssignStatement {}
class @sdmlFunctionCallStatement : @sdmlStatement { @lstring funcName @sdmlExpressionList arguments }
class @sdmlMethodStatement : @sdmlStatement { @lstring parentScheduler @lstring methodName @argumentCallList arguments }
class @sdmlIfStatement : @sdmlStatement { @sdmlExpression condition @statementList trueStatements @statementList falseStatements }
class @sdmlMoveStatement : @sdmlStatement { @lstringlist source @migrationDestination destination }
class @sdmlStartStatement : @sdmlStatement { @lstringlist timer @sdmlExpression delay @bool periodic @lstringlist methodName }
class @sdmlForeachStatement : @sdmlStatement { @sdmlItemAndContainerList iteration @statementList statements }
class @sdmlMoveeachStatement : @sdmlStatement { @lstringlist srcItem @lstringlist srcContainer @migrationDestination destination @sdmlExpression whileCondition }
class @sdmlMoveeacheachStatement : @sdmlStatement { @lstringlist srcItem @lstringlist srcContainer @lstring dstItem @lstringlist dstContainer @sdmlExpression whileCondition }

#list @sdmlStatementList { @sdmlStatement statement }

#-----------------------------------------------------------------------------
# 
#-----------------------------------------------------------------------------
getter @statement sdmlStatement
  ?let @os unused os
  ?let @lstring unused parent
  -> @sdmlStatement outStatement
{
  error .here: "the @statement sdmlStatement getter should not be called": outStatement
}

method @assignStatement number
  ?let @os os
  ?let @string operatorString
{
  @sdmlType type = [[os varDeclarations] identifierType !identifier !os]
  if [type dynamicType] != `@sdmlUnsigned & [type dynamicType] != `@sdmlInteger then
    error loc: operatorString + " operator expects integers or unsigned expression types"
  end
}

method @assignExpressionStatement sameType
  ?let @os os
  ?let @string operatorString
  !@sdmlExpression exp
{
  exp = [rightValue sdmlExpression !os]
  @sdmlType type = [[os varDeclarations] identifierType !identifier !os]
  if not [type isEqualTo ![exp type]] then
    error loc: operatorString + " right expression type does not match the identifier"
  end
}

method @assignExpressionStatement sameTypeAndNumber
  ?let @os os
  ?let @string operatorString
  !@sdmlExpression exp
{
  @sdmlType type = [[os varDeclarations] identifierType !identifier !os]
  if [type dynamicType] == `@sdmlUnsigned | [type dynamicType] == `@sdmlInteger then
    [self sameType !os !operatorString ?exp]
  else
    error loc: operatorString + " operator expects integers or unsigned expression types": exp
  end
}

method @assignExpressionStatement numberAndUnsigned
  ?let @os os
  ?let @string operatorString
  !@sdmlExpression exp
{
  @sdmlType type = [[os varDeclarations] identifierType !identifier !os]
  if [type dynamicType] == `@sdmlUnsigned | [type dynamicType] == `@sdmlInteger then
    exp = [rightValue sdmlExpression !os]
    if [[exp type] dynamicType] != `@sdmlUnsigned then
      error loc: operatorString + " operator expects right unsigned expression types"
    end
  else
    error loc: operatorString + " operator expects integers or unsigned expression types": exp
  end
}

override getter @assignExpressionStatement sdmlStatement
  ?let @os os
  ?let @lstring unused parent
  -> @sdmlStatement outStatement
{
  @sdmlExpression exp
  [self sameType !os !"=" ?exp]
  outStatement = @sdmlAssignExpressionStatement.new{!loc !identifier !exp}
}

override getter @assignAddStatement sdmlStatement
  ?let @os os
  ?let @lstring unused parent
  -> @sdmlStatement outStatement
{
  @sdmlExpression exp
  [self sameTypeAndNumber !os !"+=" ?exp]
  outStatement = @sdmlAssignAddStatement.new{!loc !identifier !exp}
}

override getter @assignSubStatement sdmlStatement
  ?let @os os
  ?let @lstring unused parent
  -> @sdmlStatement outStatement
{
  @sdmlExpression exp
  [self sameTypeAndNumber !os !"-=" ?exp]
  outStatement = @sdmlAssignSubStatement.new{!loc !identifier !exp}
}

override getter @assignMulStatement sdmlStatement
  ?let @os os
  ?let @lstring unused parent
  -> @sdmlStatement outStatement
{
  @sdmlExpression exp
  [self sameTypeAndNumber !os !"*=" ?exp]
  outStatement = @sdmlAssignMulStatement.new{!loc !identifier !exp}
}

override getter @assignDivStatement sdmlStatement
  ?let @os os
  ?let @lstring unused parent
  -> @sdmlStatement outStatement
{
  @sdmlExpression exp
  [self sameTypeAndNumber !os !"/=" ?exp]
  outStatement = @sdmlAssignDivStatement.new{!loc !identifier !exp}
}

override getter @assignRemainStatement sdmlStatement
  ?let @os os
  ?let @lstring unused parent
  -> @sdmlStatement outStatement
{
  @sdmlExpression exp
  [self sameTypeAndNumber !os !"%=" ?exp]
  outStatement = @sdmlAssignRemainStatement.new{!loc !identifier !exp}
}

override getter @assignAndStatement sdmlStatement
  ?let @os os
  ?let @lstring unused parent
  -> @sdmlStatement outStatement
{
  @sdmlExpression exp
  [self sameTypeAndNumber !os !"&=" ?exp]
  outStatement = @sdmlAssignAndStatement.new{!loc !identifier !exp}
}

override getter @assignOrStatement sdmlStatement
  ?let @os os
  ?let @lstring unused parent
  -> @sdmlStatement outStatement
{
  @sdmlExpression exp
  [self sameTypeAndNumber !os !"|=" ?exp]
  outStatement = @sdmlAssignOrStatement.new{!loc !identifier !exp}
}

override getter @assignShiftLeftStatement sdmlStatement
  ?let @os os
  ?let @lstring unused parent
  -> @sdmlStatement outStatement
{
  @sdmlExpression exp
  [self numberAndUnsigned !os !"<<" ?exp]
  outStatement = @sdmlAssignShiftLeftStatement.new{!loc !identifier !exp}
}

override getter @assignShiftRightStatement sdmlStatement
  ?let @os os
  ?let @lstring unused parent
  -> @sdmlStatement outStatement
{
  @sdmlExpression exp
  [self numberAndUnsigned !os !">>" ?exp]
  outStatement = @sdmlAssignShiftRightStatement.new{!loc !identifier !exp}
}

override getter @assignIncStatement sdmlStatement
  ?let @os os
  ?let @lstring unused parent
  -> @sdmlStatement outStatement
{
  [self number !os !"++"]
  outStatement = @sdmlAssignIncStatement.new{!loc !identifier}
}

override getter @assignDecStatement sdmlStatement
  ?let @os os
  ?let @lstring unused parent
  -> @sdmlStatement outStatement
{
  [self number !os !"--"]
  outStatement = @sdmlAssignDecStatement.new{!loc !identifier}
}

override getter @ifStatement sdmlStatement
  ?let @os os
  ?let @lstring parent
  -> @sdmlStatement outStatement
{
  @sdmlExpression ifCondition = [condition sdmlExpression !os]
  @statementList IfTrueStatements = .emptyList
  @statementList IfFalseStatements = .emptyList
  if [[ifCondition type] dynamicType] == `@sdmlBool then
    for () in trueStatements do
      IfTrueStatements += ![statement sdmlStatement !os !parent]
    end
    for () in  falseStatements do
      IfFalseStatements += ![statement sdmlStatement !os !parent]
    end
    outStatement = @sdmlIfStatement.new{!loc !ifCondition !IfTrueStatements !IfFalseStatements}
  else
    error loc: "Condition expression of a if statement should be boolean": outStatement
  end
}

override getter @moveStatement sdmlStatement
  ?let @os os
  ?let @lstring unused parent
  -> @sdmlStatement outStatement
{
  @sdmlType sourceType = [[os varDeclarations] identifierType !source !os]
#  log sourceType
  # the source must be a task
  if [sourceType dynamicType] != `@sdmlTaskRef & [sourceType dynamicType] != `@sdmlTaskContainer then
    error loc: "source of a 'move ... to ...' statement must be a task reference type": outStatement
  else
    [destination checkSource !os !source]
    outStatement = @sdmlMoveStatement.new{!loc !source !destination}
  end
}

#-----------------------------------------------------------------------------
# For a @methodStatement verify the method exists
#-----------------------------------------------------------------------------
override getter @schedulerMethodStatement sdmlStatement
  ?let @os os
  ?let @lstring parent
  -> @sdmlStatement outStatement
{
  # local method call. Get the scheduler declaration
  @schedulerDeclaration myScheduler
  if not [[os schedulerDeclarations] hasKey ![parent string]] then
    error loc: "method does not exists, did you forget to prefix it by the name of the scheduler ?": myScheduler
  else
    [[os schedulerDeclarations] getScheduler !parent ?myScheduler]
  end
  @methodDeclaration theMethod
  [[myScheduler methods] getMethod !methodName ?theMethod]
  outStatement = @sdmlMethodStatement.new{!loc !scheduler !methodName !arguments}
}

#-----------------------------------------------------------------------------
# For a @startStatement the following is checked
# - the timer exists
# - the method exists
# - the delay evaluates to an unsigned integer
#-----------------------------------------------------------------------------
getter @lstringlist location ->@location loc{
  @lstring last
  [self last ?last]
  loc = [last location]
}

getter @lstringlist string ->@string st{
  st = ""
  for () in self do
    st += [mValue string]
  between
    st += "."
  end
}

override getter @startStatement sdmlStatement
  ?let @os os
  ?let @lstring unused parent
  -> @sdmlStatement outStatement
{
  # check the timer
  if [[[os varDeclarations] identifierType !timer !os] dynamicType] != `@sdmlTimer then
    error [timer location]: [timer string]+ " is not a timer"
  end
  
  # check the method
  
  # check the delay
  @sdmlExpression sdmlDelay = [delay sdmlExpression !os]
  if [[sdmlDelay type] dynamicType] == `@sdmlUnsigned then
    outStatement = @sdmlStartStatement.new{!loc !timer !sdmlDelay !periodic !methodName}
  else
    error [sdmlDelay loc]: "Unsigned expression expected": outStatement
  end
}

#-----------------------------------------------------------------------------
# For a @foreachStatement the following is checked
# - the container is of type container
#-----------------------------------------------------------------------------
list @sdmlItemAndContainerList {
  @lstring item
  @lstringlist container
  @sdmlExpression where
}

override getter @foreachStatement sdmlStatement
  ?let @os os
  ?let @lstring parent
  -> @sdmlStatement outStatement
{
  # check the containers type and add the items in a varDeclarationMap
  @varDeclarationMap localMap = @varDeclarationMap.mapWithMapToOverride{![os varDeclarations]}
  @sdmlItemAndContainerList verifiedIteration = .emptyList
  for () in iteration do
    @sdmlType containerType = [[os varDeclarations] identifierType !container !os]
    if not [containerType isCollection] then
      error [container location]: [container string]+" is not a queue type"
    else
      @varDeclarationMap iterationLocalMap = @varDeclarationMap.mapWithMapToOverride{![os varDeclarations]}
      [!?iterationLocalMap putData !item !@refVar.new{!item ![containerType itemType !os] !rwAccess()}]
      @os osWithIterationLocals = @os.new{![os name] ![os typeDeclarations] !iterationLocalMap ![os funcDeclarations] ![os schedulerDeclarations] ![os transDeclarations] ![os backendDeclarations]}
      @sdmlExpression verifiedWhere = [where sdmlExpression !osWithIterationLocals]
      # check the type
      if [[verifiedWhere type] dynamicType] != `@sdmlBool then
        error [verifiedWhere loc]: "Boolean expression expected"
      end
      verifiedIteration += !item !container !verifiedWhere
      [!?localMap putData !item !@refVar.new{!item ![containerType itemType !os] !rwAccess()}]
    end
  end
  @statementList verifiedStatements = .emptyList
  @os osWithLocals = @os.new{![os name] ![os typeDeclarations] !localMap ![os funcDeclarations] ![os schedulerDeclarations] ![os transDeclarations] ![os backendDeclarations]}
  for () in statements do
    @sdmlStatement verifiedStatement = [statement sdmlStatement !osWithLocals !parent]
    verifiedStatements += !verifiedStatement
  end
  outStatement = @sdmlForeachStatement.new{!loc !verifiedIteration !verifiedStatements}
}

#-----------------------------------------------------------------------------
# For a @moveachStatement
#-----------------------------------------------------------------------------
override getter @moveeachStatement sdmlStatement
  ?let @os os
  ?let @lstring unused parent
  -> @sdmlStatement outStatement
{
  # Check the source of the moveeach, it should be a container
  @sdmlType srcContainerType = [[os varDeclarations] identifierType !srcContainer !os]
  if not [srcContainerType isCollection] then
    error [srcContainer location]: [srcContainer string]+" is not a queue type": outStatement
  else
    # it is a container, so check the srcWhere expression
    @varDeclarationMap iterationLocalMap = @varDeclarationMap.mapWithMapToOverride{![os varDeclarations]}
    # the first identifier of the srcItem is the item of the container
    # the second identifier is the running attribute
    @lstring primaryIdentifier
    [srcItem first ?primaryIdentifier]
    [!?iterationLocalMap putData !primaryIdentifier !@refVar.new{!primaryIdentifier ![srcContainerType itemType !os] !roAccess()}]
    @os osWithIterationLocals = @os.new{![os name] ![os typeDeclarations] !iterationLocalMap ![os funcDeclarations] ![os schedulerDeclarations] ![os transDeclarations] ![os backendDeclarations]}
    @sdmlExpression verifiedCondition = [whileCondition sdmlExpression !osWithIterationLocals]
    # check the type
    if [[verifiedCondition type] dynamicType] != `@sdmlBool then
      error [verifiedCondition loc]: "Boolean expression expected": outStatement
    else
      # check the destination of the to, it should a container to
      [destination checkSource !osWithIterationLocals !srcItem]
      outStatement = @sdmlMoveeachStatement.new{!loc !srcItem !srcContainer !destination !verifiedCondition}
    end
  end    
}

#-----------------------------------------------------------------------------
# For a @moveachStatement
#-----------------------------------------------------------------------------
override getter @moveeacheachStatement sdmlStatement
  ?let @os os
  ?let @lstring unused parent
  -> @sdmlStatement outStatement
{
  # Check the source of the moveeach, it should be a container
  @sdmlType srcContainerType = [[os varDeclarations] identifierType !srcContainer !os]
  if not [srcContainerType isCollection] then
    error [srcContainer location]: [srcContainer string]+" is not a queue type": outStatement
  else
    # it is a container
    @varDeclarationMap iterationLocalMap = @varDeclarationMap.mapWithMapToOverride{![os varDeclarations]}
    # the first identifier of the srcItem is the item of the container
    # the second identifier is the running attribute
    @lstring primaryIdentifier
    [srcItem first ?primaryIdentifier]
    [!?iterationLocalMap putData !primaryIdentifier !@refVar.new{!primaryIdentifier ![srcContainerType itemType !os] !roAccess()}]
    # check the destination of the toeach, it should a container to
    @sdmlType dstContainerType = [[os varDeclarations] identifierType !dstContainer !os]
    if not [dstContainerType isCollection] then
      error [dstContainer location]: [dstContainer string]+" is not a queue type": outStatement
    else
      [!?iterationLocalMap putData !dstItem !@refVar.new{!dstItem ![dstContainerType itemType !os] !roAccess()}]
      @os osWithIterationLocals = @os.new{![os name] ![os typeDeclarations] !iterationLocalMap ![os funcDeclarations] ![os schedulerDeclarations] ![os transDeclarations] ![os backendDeclarations]}
      @sdmlExpression verifiedCondition = [whileCondition sdmlExpression !osWithIterationLocals]
      # check the type
      if [[verifiedCondition type] dynamicType] != `@sdmlBool then
        error [verifiedCondition loc]: "Boolean expression expected": outStatement
      else
          outStatement = @sdmlMoveeacheachStatement.new{!loc !srcItem !srcContainer !dstItem !dstContainer !verifiedCondition}
      end
    end
  end    
}

override getter @functionCallStatement sdmlStatement
  ?let @os os
  ?let @lstring unused parent
  -> @sdmlStatement outStatement
{
  # Check the return Type is none
  @funcDeclaration declaration
  [[os funcDeclarations] getFunction !funcName ?declaration]
  if [[declaration type] dynamicType] != `@sdmlNone then
    error funcName: "function with no return type expected"
  end
  # Check the arguments
  @sdmlExpressionList args = .emptyList
  for () in [declaration arguments], () in arguments do
    # get the type of the actual argument
    @sdmlExpression actualArgument = [exp sdmlExpression !os]
    if not [[actualArgument type] isEqualTo !type] then
      error [actualArgument loc]: [type typeName]+" expected, got "+[[actualArgument type] typeName]
    end
    args += !actualArgument
  end
  outStatement = @sdmlFunctionCallStatement.new{!loc !funcName !args}
}

#override getter @sendStatement sdmlStatement
#  ??@scheduler scheduler
#  ??@dataMap data
#  -> @sdmlStatement outStatement
#:
#  if  [[scheduler events] hasKey ![event string]] then
#    @exprType type
#    [data get !target ?type ?* ?*]
#    if type == [@exprType processType] then
#      outStatement = [@sdmlSendStatement new !loc !event !target]
#    else
#      error loc: "Process expected as target": outStatement
#    end
#  else
#    error loc: "event ".[event string]." is not declared": outStatement
#  end  
#end

#-----------------------------------------------------------------------------
# 
#-----------------------------------------------------------------------------
list @methodList {
  @statementList statements
}

class @scheduler {
  @lstring schedulerName
  @lstring taskType
  @lstring cpuType
  @methodList methods
}

#method @scheduler check:
#  foreach handlers do
#    foreach statements do
##      [statement check]
#    end foreach
#  end foreach
#}

getter @typeDeclaration fieldType
  ?let @os os
  ?@lstringlist identifierName
  ->@sdmlType result
{
  result = [fields identifierType !identifierName !os]
}

getter @typeDeclaration allFields
  ?let @os unused os
  ->@varDeclarationMap all
{
  all = fields
}

override getter @taskDeclaration allFields
  ?let @os os
  ->@varDeclarationMap all
{
  all = fields
  if [father string] != "" then
    @typeDeclaration fatherTask
    [[os typeDeclarations] getTaskType !father ?fatherTask]
    @varDeclarationMap ancestors = [fatherTask allFields !os]
    for () in ancestors do
      [!?all putData !lkey !variable]
    end 
  end
}

override getter @taskDeclaration fieldType
  ?let @os os
  ?@lstringlist identifierName
  ->@sdmlType result
{
  @varDeclarationMap allFields = [self allFields !os]
  result = [allFields identifierType !identifierName !os]
}

getter @builtInVar varType
  ?let @os unused os
  ?@lstringlist identifierName
  ->@sdmlType result
{
  if [type dynamicType] == `@sdmlTimer then
    if [identifierName length] == 0 then
      result = type
    elsif [identifierName length] == 1 then
      @lstring attribute
      [identifierName first ?attribute]
      if [attribute string] == "date" | [attribute string] == "remaining" then
        result = @sdmlUnsigned.new{}
      else
        error attribute: "unknow timer method": result
      end
    else
      @lstring attribute
      [identifierName first ?attribute]
      error attribute: "unknow timer method": result
    end
  else
    if [identifierName length] == 0 then
      result = type
    else
      error name: "scalar type has no attribute": result
    end
  end
}

override getter @refVar varType
  ?let @os os
  ?@lstringlist identifierName
  ->@sdmlType result
{
  if [identifierName length] == 0 then
    result = type
  else
    @lstring fieldName
    [identifierName first ?fieldName]
    if [fieldName string] == "isempty" then
      if [identifierName length] == 1 then
        result = @sdmlBool.new{}
      else
        error fieldName: "isempty has no subattribute": result
      end
    elsif [type isCollection] then
      if [fieldName string] == "first" | [fieldName string] == "last" then
#        log identifierName
        if [identifierName length] == 1 then
          result = [type itemType !os]
#          log type
#          log result
        else
          [!?identifierName popFirst ?fieldName]
          @typeDeclaration typeDeclaration
          [[os typeDeclarations] getType ![type lTypeName] ?typeDeclaration]
          result = [typeDeclaration fieldType !os !identifierName]
        end
      else
        error fieldName: "unknown field": result
      end
    else
#      log identifierName
#      log "DATA STRUCT": self
#      log context
      if [identifierName length] == 1 then
        @typeDeclaration typeDeclaration
        [[os typeDeclarations] getType ![type lTypeName] ?typeDeclaration]
        result = [typeDeclaration fieldType !os !identifierName]
      else
        @typeDeclaration typeDeclaration
        [[os typeDeclarations] getType ![type lTypeName] ?typeDeclaration]
#        @declaration fieldDeclaration
#        [typeDeclaration get !fieldName ?fieldDeclaration]
        
#        message "############################\n"
#        log identifierName
#        log fieldDeclaration
        result = [typeDeclaration fieldType !os !identifierName]
#          message "############################\n"
      end
    end
  end
}

getter @varDeclarationMap identifierType
  ?@lstringlist identifierName
  ?let @os os
  ->@sdmlType type
{
  @lstring primaryIdentifierName
  [!?identifierName popFirst ?primaryIdentifierName]
  @varDeclaration identifier
  [self getData !primaryIdentifierName ?identifier]
  cast identifier
    case >= @builtInVar biv :
      type = [biv varType !os !identifierName]
    else
      error primaryIdentifierName : [primaryIdentifierName string]+" is not a type": type
  end
}

getter @typeDeclarationMap ancestorsList
  ?let @lstring leafType
  ->@lstringlist typeList
{
  if [leafType string] != "" then
    typeList = @lstringlist.listWithValue{!leafType}
    @typeDeclaration leafTypeDeclaration
    [self getTaskType !leafType ?leafTypeDeclaration]
    cast leafTypeDeclaration
    case == @taskDeclaration td :
      @lstringlist ancestors = [self ancestorsList ![td father]]
      typeList = typeList + ancestors
    else
      error leafType: "type "+leafType+" should be a task type": typeList
    end
  else
    typeList = @lstringlist.emptyList
  end
}

getter @varDeclarationMap identifierTypeList
  ?@lstringlist identifierName
  ?let @os os
  ->@lstringlist typeList
{
 @sdmlType type = [self identifierType !identifierName !os]
 typeList = [[os typeDeclarations] ancestorsList ![type lTypeName]]
}
  
getter @lstringlist mayContain
  ?let @lstring otherType
  ->@bool result
{
  result = false
  for () in self do
    result = result | ([mValue string] == [otherType string])
  end
}


#function findIdentifierType
#  ?@lstringlist identifier
#  ??@declarationMap declarations
#  ->@exprType type
#:
#  @lstring primaryIdentifier
#  [!?identifier popFirst ?primaryIdentifier]
# 
#  # look for it in the local data
#  @exprType identifierType
#  
#  [declarations getData !primaryIdentifier ?identifierType ?* ?*]
#  if identifierType == [@exprType processType] then
#    if [identifier length] > 0 then
#      @lstring secondaryIdentifier
#      [!?identifier popFirst ?secondaryIdentifier]
#      @typeMap proc = [scheduler process]
#      @lstring className
#      [proc get !secondaryIdentifier ?* ?* ?identifierType ?className]
#      if identifierType == [@exprType objectType] then
#        if [identifier length] > 0 then
#          @lstring tertiaryIdentifier
#          [!?identifier popFirst ?tertiaryIdentifier]
#          @typeMap fields
#          [[scheduler classes] get !className ?fields]
#          [fields get !tertiaryIdentifier ?* ?* ?identifierType ?*]
#        end
#      end
#    end
#  end
#  type = identifierType
#end function

#routine checkStatements
#  ??@scheduler scheduler
#  ??@dataMap data
#  ??@statementList statements
#:
#  foreach statements do
#    @sdmlStatement sdmlStatement = [statement sdmlStatement !scheduler !data]
#  end foreach
#end routine

#method @transitionEventStatement check
#  ??@scheduler scheduler
#  ??@dataMap data
#:
#  [[scheduler states] get !sourceState]
#  [[scheduler states] get !destinationState]
#  @sdmlExpression cond = [condition sdmlExpression !scheduler !data]
#  if [cond type] != [@exprType boolType] then
#    error [cond loc]: "boolean expression expected"
#  end
#}

#routine checkEvents
#  ??@scheduler scheduler
#:
#  foreach [scheduler handlers] do
#    checkStatements !scheduler ![scheduler globals] !statements
#  end foreach
#  foreach [scheduler events] do
#    @dataMap localData = [@dataMap mapWithMapToOverride ![scheduler globals]]
#    [!?localData put !processName ![@exprType processType] !false !emptylstring[]]
#    checkStatements !scheduler !localData ![[event beforeActions] codeStatements]
#    checkStatements !scheduler !localData ![[event afterActions] codeStatements]
#    foreach [event transitions] do
#      checkStatements !scheduler !localData ![transition code]
#      [transition check !scheduler !localData]
#    end foreach 
#  end foreach
#  foreach [scheduler rules] do
#    @sdmlExpression cond = [condition sdmlExpression !scheduler ![scheduler globals]]
#    if [cond type] != [@exprType boolType] then
#      error [cond loc]: "Boolean expression expected"
#    end
#    checkStatements !scheduler ![scheduler globals] !statements
#  end foreach
#end routine
#
#routine checkScheduler
#  ??@scheduler scheduler
#:
#  checkEvents !scheduler
#end routine

#---------------------------------------------------------------------------*
# itemType getter
#
getter @sdmlType itemType
  ?let @os unused os
  ->@sdmlType result
{
  result = self
}

override getter @sdmlCollection itemType
  ?let @os os
  ->@sdmlType result
{
  @typeDeclaration type
  [[os typeDeclarations] getType !name ?type]
  cast type
  case == @taskDeclaration :
    result = @sdmlTaskRef.new{!name}
  case == @cpuDeclaration :
    result = @sdmlCpuRef.new{!name}
  else
    error name: "unexpected item type": result
  end
}
