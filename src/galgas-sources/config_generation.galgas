getter @os configuration
  ->@gtlData config
{
  config := @gtlStruct.new { !.here !emptylstring() !.emptyMap }
  
  [!?config setStructField
    !@lstring.new { !"OS" !.here }
    !@gtlString.new { !.here !lstring("Name of the OS") !name }
  ]

  # 1 - the data type
  [!?config setStructField
    !@lstring.new { !"TYPES" !.here }
    ![typeDeclarations fieldMap]
  ]
  
  # 2 - the vars
  @gtlStruct globals = [varDeclarations fieldMap !typeDeclarations]
  [!?config setStructField
    !@lstring.new { !"VARIABLES" !.here }
    !globals
  ]
  
  # 3 - the scheduler, currently only one schedule is handled
  @gtlStruct schedulers = [schedulerDeclarations fieldMap !typeDeclarations]
  [!?config setStructField
    !@lstring.new { !"SCHEDULERS" !.here }
    !schedulers
  ]
  
  # - backends
  @gtlMap backends = .new { !.here !lstring("defined backends") !.emptyMap }
  for () in backendDeclarations do
    [backend configuration !?backends];
  end
  [!?config setStructField
    !@lstring.new { !"BACKENDS" !.here }
    !backends
  ]
}

getter @typeDeclarationMap fieldMap
  ->@gtlStruct result
{
  result = .new { !.here !emptylstring() !.emptyMap }
  for () in self do
    [!?result setStructField
      !lkey
      ![type fieldMap !self]
    ]
  end
}

getter @schedulerDeclarationMap fieldMap
  ?let @typeDeclarationMap types
  ->@gtlStruct result
{
  result = .new { !.here !emptylstring() !.emptyMap }
  for () in self do
    [!?result setStructField
      !lkey
      ![scheduler fieldMap !types]
    ]
  end
}

getter @schedulerDeclaration fieldMap
  ?let @typeDeclarationMap types
  ->@gtlStruct result
{
  result = .new { !.here !emptylstring() !.emptyMap }
  [!?result setStructField
    !@lstring.new { !"NAME" !.here }
    !@gtlString.new { !.here !name }
  ]
  [!?result setStructField
    !@lstring.new { !"TASK" !.here }
    !@gtlString.new { !.here !task }
  ]
  [!?result setStructField
    !@lstring.new { !"CPU" !.here }
    !@gtlString.new { !.here !cpu }
  ]
  [!?result setStructField
    !@lstring.new { !"VARIABLES" !.here }
    ![locals fieldMap !types]
  ]
  [!?result setStructField
    !@lstring.new { !"METHODS" !.here }
    ![methods fieldMap !types]
  ]
}

getter @methodDeclarationMap fieldMap
  ?let @typeDeclarationMap types
  ->@gtlStruct result
{
  result = .new { !.here !emptylstring() !.emptyMap }
  for () in self do
    [!?result setStructField
      !lkey
      ![methodDeclaration fieldMap !types]
    ]
  end
}

getter @methodDeclaration fieldMap
  ?let @typeDeclarationMap types
  ->@gtlStruct result
{
  result = .new { !.here !emptylstring() !.emptyMap }
  [!?result setStructField
    !@lstring.new { !"NAME" !.here }
    !@gtlString.new { !.here !name }
  ]
  [!?result setStructField
    !@lstring.new { !"VARIABLES" !.here }
    ![locals fieldMap !types]
  ]
  [!?result setStructField
    !@lstring.new { !"STATEMENTS" !.here }
    ![statements fieldMapList]
  ]
}

abstract getter @typeDeclaration fieldMap
  ?let @typeDeclarationMap types
  ->@gtlStruct
  
method @typeDeclaration typeAndFields
  ?let @typeDeclarationMap types
  ?!@gtlStruct config
{
  [!?config setStructField
    !@lstring.new { !"NAME" !.here }
    !@gtlString.new { !.here !name }
  ]
  [!?config setStructField
    !@lstring.new { !"FIELDS" !.here }
    ![fields fieldMap !types]
  ]
}

method @lstringmap configuration
  ?!@gtlStruct config
{
  @lstringset statesSet = .emptyMap 
  for () in self do
    [!?states put
      !lkey
    ]
  end
  [!?config setStructField
    !@lstring.new { !"STATES" !.here }
    !@gtlSet.new { !.here !statesSet }
  ]
}

override getter @taskDeclaration fieldMap
  ?let @typeDeclarationMap types
  ->@gtlStruct result
{
  result := [@TfieldMap emptyMap];
  [selfcopy typeAndFields !types !?result];
  addLStringValue !?result !"FATHER" !father;
  addLStringValue !?result !"KIND" !lstringwith[!"TASK"];
  [states configuration !?result];
}

abstract method @acceptStatement acceptStatement ?!@TfieldMap st;

override method @emptyAcceptStatement acceptStatement ?!@TfieldMap st:
  addLStringValue !?st !"CPUSTATE" !cpuState;
end method;

override method @taskAcceptStatement acceptStatement ?!@TfieldMap st:
  addLStringValue !?st !"CPUSTATE" !cpuState;
  addLStringValue !?st !"TASKSTATE" !taskState;
end method;

method @acceptMap configuration
  ?!@TfieldMap config
:
  @TfieldMap states [emptyMap];
  foreach selfcopy do
    @TfieldMap st [emptyMap];
    [accept acceptStatement !?st];
    addStructValue !?states ![accept cpuState] !st;
  end foreach;
  addMapValue !?config !lstringwith[!"STATES"] !states;
end method;

override getter @cpuDeclaration fieldMap ??@typeDeclarationMap types ->@TfieldMap result
:
  result := [@TfieldMap emptyMap];
  [selfcopy typeAndFields !types !?result];
  addLStringValue !?result !"TASK" !task;
  addLStringValue !?result !"KIND" !lstringwith[!"CPU"];
  [states configuration !?result];
end getter;
 
getter @varDeclarationMap fieldMap ??@typeDeclarationMap types ->@TfieldMap result:
  result := [@TfieldMap emptyMap];
  foreach selfcopy do
    addStructValue !?result !lkey ![var fieldMap !types];
  end foreach;
end getter;

abstract getter @varDeclaration fieldMap ??@typeDeclarationMap types ->@TfieldMap result;
  
override getter @builtInVar fieldMap ??@typeDeclarationMap unused types ->@TfieldMap result:
  result := [@TfieldMap emptyMap];
  addLStringValue !?result !"NAME" !name;
  addStringValue !?result !lstringwith[!"TYPE"] ![type typeName];
end getter;

override getter @sdmlContainerVar fieldMap ??@typeDeclarationMap types ->@TfieldMap result:
  result := [@TfieldMap emptyMap];
  [states configuration !?result];
  [ordering configuration !?result];
  addLStringValue !?result !"NAME" !name;
  addStringValue !?result !lstringwith[!"TYPE"] ![type typeName];
  if [type isCollection] then
    addStringValue !?result !lstringwith[!"QUEUE"] !"YES";
  else
    addStringValue !?result !lstringwith[!"QUEUE"] !"NO";
  end if;
  # lookup the type in types
  @typeDeclaration containerType;
  [types getType ![type lTypeName] ?containerType];
  addStructValue !?result !lstringwith[!"REFTYPE"] ![containerType fieldMap !types];
end getter;

method @sdmlOrderingList configuration
  ?!@TfieldMap config
:
  @TfieldMapList order [emptyList];
  foreach selfcopy do
    @TfieldMap criterion [emptyMap];
    addStructValue !?criterion !lstringwith[!"KEYS"] ![key fieldMap];
    if up then
      addStringValue !?criterion !lstringwith[!"SORTING"] !"<";
    else
      addStringValue !?criterion !lstringwith[!"SORTING"] !">";
    end if;
    order += !criterion;
  end foreach;
  addListValue !?config !lstringwith[!"ORDERING"] !order;
end method;

method @backendDeclaration configuration
  ?!@TfieldMap config
:
  @TfieldMap backAttributes [emptyMap];
  addLStringValue !?backAttributes !"NAME" !name;
  @TfieldMapList args := [arguments fieldMapList];
  addListValue !?backAttributes !lstringwith[!"ARGUMENTS"] !args;
  @TfieldMap keyedStats := [keyedStatements fieldMap];
  addMapValue !?backAttributes !lstringwith[!"HANDLERS"] !keyedStats;
  @TfieldMap keyedIdents := [keyedIdentifiers fieldMap];
  addMapValue !?backAttributes !lstringwith[!"IDENTIFIERS"] ! keyedIdents;
  addStructValue !?config !name !backAttributes;
end method;

getter @argumentList fieldMapList
  ->@TfieldMapList result
:
  result := [@TfieldMapList emptyList];
  foreach selfcopy do
    @TfieldMap attrs [emptyMap];
    addLStringValue !?attrs !"NAME" !name;
    addLStringValue !?attrs !"TYPE" ![type lTypeName];
    result += !attrs;
  end foreach;
end getter;

getter @keyedStatementMap fieldMap
  ->@TfieldMap result
:
  result := [@TfieldMap emptyMap];
  foreach selfcopy do
    @TfieldMapList statements := [statements fieldMapList];
    addListValue !?result !lkey !statements;
  end foreach;
end getter;

getter @keyedIdentifierMap fieldMap
  ->@TfieldMap result
:
  result := [@TfieldMap emptyMap];
  foreach selfcopy do
    @TfieldMapList statements := [identifier fieldMapList];
    addListValue !?result !lkey !statements;
  end foreach;
end getter;

getter @statementList fieldMapList
  ->@TfieldMapList result
:
  result := [@TfieldMapList emptyList];
  foreach selfcopy do
    @TfieldMap stat := [statement fieldMap];
    result += !stat;
  end foreach;
end getter;

getter @statement fieldMap ->@TfieldMap result:
  error here: "fieldMap should not be called on this statement": result;
  message [selfcopy description];
end getter;

override getter @sdmlAssignExpressionStatement fieldMap ->@TfieldMap result:
  result := [@TfieldMap emptyMap];
  addStringValue !?result ![@lstring new !"NAME" !loc] !"ASSIGN";
  addListValue !?result !lstringwith[!"IDENTIFIER"] ![identifier fieldMapList];
  addStructValue !?result !lstringwith[!"EXP"] ![rightValue fieldMap];
#  @TfieldMapList ident := [identifier fieldMapList];
end getter;

override getter @sdmlMoveStatement fieldMap ->@TfieldMap result:
  result := [@TfieldMap emptyMap];
  addStringValue !?result ![@lstring new !"NAME" !loc] !"MOVE";
  @TfieldMapList src := [source fieldMapList];
  addListValue !?result !lstringwith[!"SOURCE"] !src;
  @TfieldMap dest := [destination fieldMap];
  addStructValue !?result ![@lstring new !"DESTINATION" ![destination loc]] !dest;
end getter;

getter @lstringlist fieldMapList ->@TfieldMapList result:
  result := [@TfieldMapList emptyList];
  foreach selfcopy do
    @TfieldMap item [emptyMap];
    addLStringValue !?item !"IDENT" !mValue;
    result += !item;
  end foreach;
end getter;

abstract getter @migrationDestination fieldMap ->@TfieldMap result;

override getter @containerDestination fieldMap ->@TfieldMap result:
  result := [@TfieldMap emptyMap];
  addStringValue !?result ![@lstring new !"KIND" !loc] !"CONTAINER";
  addListValue !?result ![@lstring new !"CONTAINER" !loc] ![container fieldMapList];
end getter;

override getter @stateDestination fieldMap ->@TfieldMap result:
  result := [@TfieldMap emptyMap];
  addStringValue !?result ![@lstring new !"KIND" !loc] !"STATE";
  addLStringValue !?result !"STATE" !taskState;
end getter;

override getter @sdmlMethodStatement fieldMap ->@TfieldMap result:
  result := [@TfieldMap emptyMap];
  addStringValue !?result ![@lstring new !"NAME" !loc] !"CALL";
  addListValue !?result !lstringwith[!"METHOD"] ![identifier fieldMapList];
  addLStringValue !?result !"SCHEDULER" !parentScheduler;
end getter;

override getter @sdmlForeachStatement fieldMap ->@TfieldMap result:
  result := [@TfieldMap emptyMap];
  addStringValue !?result ![@lstring new !"NAME" !loc] !"FOREACH";
  addListValue !?result ![@lstring new !"ITEMS" !loc] ![iteration fieldMapList];
  addListValue !?result ![@lstring new !"STATEMENTS" !loc] ![statements fieldMapList];
end getter;

override getter @sdmlMoveeacheachStatement fieldMap ->@TfieldMap result:
  result := [@TfieldMap emptyMap];
  addStringValue !?result ![@lstring new !"NAME" !loc] !"MOVEEACH";
  addListValue !?result !lstringwith[!"SRCITEM"] ![srcItem fieldMapList];
  addLStringValue !?result !"DSTITEM" !dstItem;
  addListValue !?result !lstringwith[!"SRCCONTAINER"] ![srcContainer fieldMapList];
  addListValue !?result !lstringwith[!"DSTCONTAINER"] ![dstContainer fieldMapList];
  addStructValue !?result ![@lstring new !"WHILECONDITION" ![whileCondition loc]] ![whileCondition fieldMap];
end getter;

override getter @sdmlIfStatement fieldMap ->@TfieldMap result:
  result := [@TfieldMap emptyMap];
  addStringValue !?result ![@lstring new !"NAME" !loc] !"IF";
  addStructValue !?result ![@lstring new !"CONDITION" ![condition loc]] ![condition fieldMap];
  addListValue !?result !lstringwith[!"TRUESTATEMENTS"] ![trueStatements fieldMapList];
  addListValue !?result !lstringwith[!"FALSESTATEMENTS"] ![falseStatements fieldMapList];
end getter;

getter @sdmlItemAndContainerList fieldMapList ->@TfieldMapList result:
  result := [@TfieldMapList emptyList];
  foreach selfcopy do
    @TfieldMap cont [emptyMap];
    addLStringValue !?cont !"ITEM" !item;
    addListValue !?cont !lstringwith[!"CONTAINER"] ![container fieldMapList];
    addStructValue !?cont !lstringwith[!"WHERE"] ![where fieldMap];
    result += !cont;
  end foreach;
end getter;

getter @sdmlExpressionList fieldMapList ->@TfieldMapList result:
  result := [@TfieldMapList emptyList];
  foreach selfcopy do
    result += ![expr fieldMap];
  end foreach;
end getter;

abstract getter @sdmlExpression fieldMap ->@TfieldMap result;

override getter @sdmlFunctionCallNode fieldMap ->@TfieldMap result:
  result := [@TfieldMap emptyMap];
  addStringValue !?result !lstringwith[!"KIND"] !"FUNCTIONCALL";
  addLStringValue !?result !"NAME" !funcName;
  addListValue !?result !lstringwith[!"ARGS"] ![arguments fieldMapList];
end getter;

override getter @sdmlIntegerNode fieldMap ->@TfieldMap result:
  result := [@TfieldMap emptyMap];
  addStringValue !?result !lstringwith[!"KIND"] !"INTEGER";
  addLUnsignedValue !?result !"VALUE" !integerValue;
end getter;

override getter @sdmlBoolNode fieldMap ->@TfieldMap result:
  result := [@TfieldMap emptyMap];
  addStringValue !?result !lstringwith[!"KIND"] !"BOOL";
  addLBoolValue !?result !"VALUE" !boolValue;
end getter;

override getter @sdmlIdentifierNode fieldMap ->@TfieldMap result:
  result := [@TfieldMap emptyMap];
  addStringValue !?result !lstringwith[!"KIND"] !"IDENTIFIER";
  addListValue !?result !lstringwith[!"NAME"] ![identifierValue fieldMapList];
end getter;

override getter @sdmlMinNode fieldMap ->@TfieldMap result:
  result := [@TfieldMap emptyMap];
  addStringValue !?result !lstringwith[!"KIND"] !"MIN";
  addListValue !?result !lstringwith[!"CONTAINER"] ![container fieldMapList];
end getter;

override getter @sdmlMaxNode fieldMap ->@TfieldMap result:
  result := [@TfieldMap emptyMap];
  addStringValue !?result !lstringwith[!"KIND"] !"MAX";
  addListValue !?result !lstringwith[!"CONTAINER"] ![container fieldMapList];
end getter;

override getter @sdmlSubExprNode fieldMap ->@TfieldMap result:
  result := [@TfieldMap emptyMap];
  addStringValue !?result !lstringwith[!"KIND"] !"SUBEXPRESSION";
  addStructValue !?result !lstringwith[!"EXP"] ![expressionValue fieldMap];
end getter;

override getter @sdmlNotNode fieldMap ->@TfieldMap result:
  result := [@TfieldMap emptyMap];
  addStringValue !?result !lstringwith[!"KIND"] !"NOT";
  addStructValue !?result !lstringwith[!"EXP"] ![expressionValue fieldMap];
end getter;

override getter @sdmlCompNode fieldMap ->@TfieldMap result:
  result := [@TfieldMap emptyMap];
  addStringValue !?result !lstringwith[!"KIND"] !"COMP";
  addStructValue !?result !lstringwith[!"EXP"] ![expressionValue fieldMap];
end getter;

method @sdmlBinNode setExpr ?!@TfieldMap result:
  addStructValue !?result !lstringwith[!"LEFT"] ![left fieldMap];
  addStructValue !?result !lstringwith[!"RIGHT"] ![right fieldMap]; 
end method;

override getter @sdmlEqualNode fieldMap ->@TfieldMap result:
  result := [@TfieldMap emptyMap];
  addStringValue !?result !lstringwith[!"KIND"] !"EQUAL";
  [selfcopy setExpr !?result];
end getter;

override getter @sdmlDifferNode fieldMap ->@TfieldMap result:
  result := [@TfieldMap emptyMap];
  addStringValue !?result !lstringwith[!"KIND"] !"DIFFER";
  [selfcopy setExpr !?result];
end getter;

override getter @sdmlLowerEqualNode fieldMap ->@TfieldMap result:
  result := [@TfieldMap emptyMap];
  addStringValue !?result !lstringwith[!"KIND"] !"LOWEROREQUAL";
  [selfcopy setExpr !?result];
end getter;

override getter @sdmlGreaterEqualNode fieldMap ->@TfieldMap result:
  result := [@TfieldMap emptyMap];
  addStringValue !?result !lstringwith[!"KIND"] !"GREATEROREQUAL";
  [selfcopy setExpr !?result];
end getter;

override getter @sdmlLowerNode fieldMap ->@TfieldMap result:
  result := [@TfieldMap emptyMap];
  addStringValue !?result !lstringwith[!"KIND"] !"LOWER";
  [selfcopy setExpr !?result];
end getter;

override getter @sdmlGreaterNode fieldMap ->@TfieldMap result:
  result := [@TfieldMap emptyMap];
  addStringValue !?result !lstringwith[!"KIND"] !"GREATER";
  [selfcopy setExpr !?result];
end getter;

override getter @sdmlAndNode fieldMap ->@TfieldMap result:
  result := [@TfieldMap emptyMap];
  addStringValue !?result !lstringwith[!"KIND"] !"AND";
  [selfcopy setExpr !?result];
end getter;

override getter @sdmlOrNode fieldMap ->@TfieldMap result:
  result := [@TfieldMap emptyMap];
  addStringValue !?result !lstringwith[!"KIND"] !"OR";
  [selfcopy setExpr !?result];
end getter;

override getter @sdmlXorNode fieldMap ->@TfieldMap result:
  result := [@TfieldMap emptyMap];
  addStringValue !?result !lstringwith[!"KIND"] !"XOR";
  [selfcopy setExpr !?result];
end getter;

override getter @sdmlShiftLeftNode fieldMap ->@TfieldMap result:
  result := [@TfieldMap emptyMap];
  addStringValue !?result !lstringwith[!"KIND"] !"SHIFTLEFT";
  [selfcopy setExpr !?result];
end getter;

override getter @sdmlShiftRightNode fieldMap ->@TfieldMap result:
  result := [@TfieldMap emptyMap];
  addStringValue !?result !lstringwith[!"KIND"] !"SHIFTRIGHT";
  [selfcopy setExpr !?result];
end getter;

override getter @sdmlAndAndNode fieldMap ->@TfieldMap result:
  result := [@TfieldMap emptyMap];
  addStringValue !?result !lstringwith[!"KIND"] !"ANDAND";
  [selfcopy setExpr !?result];
end getter;

override getter @sdmlOrOrNode fieldMap ->@TfieldMap result:
  result := [@TfieldMap emptyMap];
  addStringValue !?result !lstringwith[!"KIND"] !"OROR";
  [selfcopy setExpr !?result];
end getter;

override getter @sdmlAddNode fieldMap ->@TfieldMap result:
  result := [@TfieldMap emptyMap];
  addStringValue !?result !lstringwith[!"KIND"] !"ADD";
  [selfcopy setExpr !?result];
end getter;

override getter @sdmlSubNode fieldMap ->@TfieldMap result:
  result := [@TfieldMap emptyMap];
  addStringValue !?result !lstringwith[!"KIND"] !"SUB";
  [selfcopy setExpr !?result];
end getter;

override getter @sdmlMulNode fieldMap ->@TfieldMap result:
  result := [@TfieldMap emptyMap];
  addStringValue !?result !lstringwith[!"KIND"] !"MUL";
  [selfcopy setExpr !?result];
end getter;

override getter @sdmlDivNode fieldMap ->@TfieldMap result:
  result := [@TfieldMap emptyMap];
  addStringValue !?result !lstringwith[!"KIND"] !"DIV";
  [selfcopy setExpr !?result];
end getter;

override getter @sdmlRemainNode fieldMap ->@TfieldMap result:
  result := [@TfieldMap emptyMap];
  addStringValue !?result !lstringwith[!"KIND"] !"REMAIN";
  [selfcopy setExpr !?result];
end getter;
