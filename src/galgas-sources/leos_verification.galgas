semantics sdml_verification:
  import "sdml_semantics.gSemantics";
  import "backend.gSemantics";

#---------------------------------------------------------------------------*
# verify the root object
# 
reader @os verify -> @os result:

  @typeDeclarationMap types [emptyMap];
  foreach typeDeclarations do
    @typeDeclaration verifiedType := [type verify !selfcopy];
    [!?types putType !lkey !verifiedType];
  end foreach;
  
  @varDeclarationMap vars [emptyMap];
  foreach varDeclarations do
    @varDeclaration verifiedVar := [var verify !selfcopy];
    [!?vars putData !lkey !verifiedVar];
  end foreach;
  
  @funcDeclarationMap funcs [emptyMap];
  foreach funcDeclarations do
    @funcDeclaration verifiedFunc := [func verify !selfcopy];
    [!?funcs putFunction !lkey !verifiedFunc];
  end foreach;
  
  @schedulerDeclarationMap schedulers [emptyMap];
  foreach schedulerDeclarations do
    @schedulerDeclaration verifiedScheduler := [scheduler verify !selfcopy];
    [!?schedulers putScheduler !lkey !verifiedScheduler];
  end foreach;
  
  @transDeclarationMap trans [emptyMap];
  foreach transDeclarations do
    @transDeclaration verifiedTrans := [transition verify !selfcopy];
    [!?trans putTrans !lkey !verifiedTrans];
  end foreach;
  
  @backendDeclarationMap backends [emptyMap];
  foreach backendDeclarations do
    @backendDeclaration verifiedBackend := [backend verify !selfcopy];
    [!?backends putBackend !lkey !verifiedBackend];
  end foreach;

  result := [@os new !name !types !vars !funcs !schedulers !trans !backends];
end reader;

abstract reader @typeDeclaration verify
  ??@os os
  ->@typeDeclaration result;
#---------------------------------------------------------------------------*
# verify the task declarations:
# - each task declaration should have an existing ancestor
# - each task state should not be redeclared
# - each task field should not be redeclared
#
override reader @taskDeclaration verify
  ??@os os
  ->@typeDeclaration result
:
  # check the father exists
  if [[os typeDeclarations] hasLKey !father] then
    @typeDeclaration theFather;
    [[os typeDeclarations] getTaskType !father ?theFather];
    cast theFather:
    when == @taskDeclaration fatherTask do
      # check the states are not redefined compared to the ancestor
      foreach states do
        if [[fatherTask states] hasKey ![lkey string]] then
          error lkey: "state '".lkey."' of task ".name;
          error [[fatherTask states] locationForKey ![lkey string]]: "conflicts with parent task state";
        end if;
      end foreach;
      # check the fields are not redefined compared to the ancestor
      foreach fields do
        if [[fatherTask fields] hasKey ![lkey string]] then
          error lkey: "field '".lkey."' of task ".name;
          error [[fatherTask fields] locationForKey ![lkey string]]: "conflicts with parent task field";
        end if;
      end foreach;
    else
      error father: "Father is not declared";
    end cast;
  end if;
  result := selfcopy;
end reader;

#---------------------------------------------------------------------------*
# verify the cpu declaration
# - each cpu state must have a corresponding task state
# - empty must exist in 1 ex
#
override reader @cpuDeclaration verify
  ??@os os
  ->@typeDeclaration result
:
  # get the task
  @typeDeclaration refobj;
  [[os typeDeclarations] getTaskType !task ?refobj];
  cast refobj:
  when == @taskDeclaration reftask do
    # verify each task state exists
    # iterate through the states of the CPU
    foreach states do
      cast accept:
      when == @taskAcceptStatement tas do
        [[reftask allStates !os] getState ![tas taskState]];
      else end cast;
    end foreach;
  else
    error task: [task string]." is not a task type";
  end cast;
  @lstringmap taskStates [emptyMap];
  @lstring lastEmpty := emptylstring[];
  foreach states do    
    cast accept:
    when == @taskAcceptStatement tas do
      [!?taskStates putState ![tas taskState]];
    when == @emptyAcceptStatement eas do
      if [lastEmpty string] != "" then
        error [eas cpuState]: "empty redefined";
        error lastEmpty: "was defined here";
      else
        lastEmpty := [eas cpuState];
      end if;
    else end cast;
  end foreach;
  result := selfcopy;
end reader;

#---------------------------------------------------------------------------*
# vars verification
#
abstract reader @varDeclaration verify
  ??@os os
  ->@varDeclaration result;

#---------------------------------------------------------------------------*
# verify a built in var, nothing to do in fact
#
override reader @builtInVar verify
  ??@os unused os
  ->@varDeclaration result
:
  result := selfcopy;
end reader;

#---------------------------------------------------------------------------*
# verify a custom var
#
#---------------------------------------------------------------------------*
# methods to check the container states conform to the declared states
#
abstract method @typeDeclaration checkStates
  ??@os os
  ??@lstringmap containerStates;

override method @taskDeclaration checkStates
  ??@os os
  ??@lstringmap containerStates
:
  @lstringmap all := [selfcopy allStates !os];
  foreach containerStates do
    if not [all hasLKey !lkey] then
      error lkey: [lkey string]." is not declared for task type ".name;
    end if;
  end foreach;
end method;

override method @cpuDeclaration checkStates
  ??@os unused os
  ??@lstringmap containerStates
:
  foreach containerStates do
    if not [states hasLKey !lkey] then
      error lkey: [lkey string]." is not declared for cpu type ".name;
    end if;
  end foreach;
end method;

#---------------------------------------------------------------------------*
# methods to check the container ordering list
# conforms to the declared fields
#
reader @orderingList sdmlOrderingList
  ??@os os
  ??@varDeclarationMap fields
  ->@sdmlOrderingList sdmlOrdering
:
  #
  # build a variable map made with fields of the item type
  #
  @os osWithSortLocals := [@os new ![os name] ![os typeDeclarations] !fields ![os funcDeclarations] ![os schedulerDeclarations] ![os transDeclarations] ![os backendDeclarations]];
  sdmlOrdering := [@sdmlOrderingList emptyList];
  foreach selfcopy do
    @sdmlExpression sdmlKey := [key sdmlExpression !osWithSortLocals];
    if not [[sdmlKey type] isOrdered] then
      error [key loc]: "Sorting key is not ordered";
    end if;
    sdmlOrdering += !sdmlKey !up;
  end foreach;
end reader;



override reader @containerVar verify
  ??@os os
  ->@varDeclaration result
:
  # look for the var type in the types
  @typeDeclaration typeDeclaration;
  [[os typeDeclarations] getType ![type lTypeName] ?typeDeclaration];
  # check the states accepted by the container exists
  [typeDeclaration checkStates !os !states];
  # check the ordering list conforms to the declared fields
  @sdmlOrderingList sdmlOrdering := [ordering sdmlOrderingList !os ![typeDeclaration allFields !os]];
  result := [@sdmlContainerVar new !name !type !access !states !sdmlOrdering];
end reader;

#---------------------------------------------------------------------------*
# verify a method
# verify each statement
#
reader @methodDeclaration verify
  ??@os os
  ??@lstring parent
  ->@methodDeclaration result
:
#  message "**** Parent = ".parent."\n";
  @statementList verifiedStatements [emptyList];
  @varDeclarationMap localMap := [@varDeclarationMap mapWithMapToOverride ![os varDeclarations]];
  foreach locals do
    [!?localMap putData !lkey !var];
  end foreach;
  @os osWithLocals := [@os new ![os name] ![os typeDeclarations] !localMap ![os funcDeclarations] ![os schedulerDeclarations] ![os transDeclarations] ![os backendDeclarations]];
  foreach statements do
    verifiedStatements += ![statement sdmlStatement !osWithLocals !parent];
  end foreach;
  result := [@methodDeclaration new !name !locals !verifiedStatements];
end reader;

#---------------------------------------------------------------------------*
# verify a scheduler
#
reader @schedulerDeclaration verify
  ??@os os
  ->@schedulerDeclaration result
:
  @varDeclarationMap decls := [@varDeclarationMap mapWithMapToOverride ![os varDeclarations]];
  foreach locals do
    @varDeclaration dec := [var verify !os];
    [!?decls putData !lkey !dec];
  end foreach;
  
  @os osWithLocals := [@os new ![os name] ![os typeDeclarations] !decls ![os funcDeclarations] ![os schedulerDeclarations] ![os transDeclarations] ![os backendDeclarations]];
  @methodDeclarationMap verifMethods [emptyMap];
  foreach methods do
    @methodDeclaration verifiedMethod := [methodDeclaration verify !osWithLocals !name];
    [!?verifMethods putMethod !lkey !verifiedMethod];
  end foreach;
  result := [@schedulerDeclaration new !name !task !cpu !decls !verifMethods];
end reader;

#---------------------------------------------------------------------------*
# verify a transition set
#
method @taskDeclaration hasState ??@lstring inState ??@os os:
  @lstringmap allStates := [selfcopy allStates !os];
  if not [allStates hasLKey !inState] then
    error inState: "State ".inState." does not exist";
  end if;
end method;

reader @transDeclaration verify
  ??@os os
  ->@transDeclaration result
:
  # check the taskType is ok
  @typeDeclaration taskTypeDeclaration;
  [[os typeDeclarations] getTaskType !taskType ?taskTypeDeclaration];
  cast taskTypeDeclaration:
  when == @taskDeclaration td do
    @varDeclaration task := [@refVar new !taskName ![@sdmlCustom new !taskType] !rwAccess[]];
    @varDeclarationMap localMap := [@varDeclarationMap mapWithMapToOverride ![os varDeclarations]];
    [!?localMap putData !taskName !task];
    @transitionList verifiedTransitions [emptyList];
    @os osWithLocals := [@os new ![os name] ![os typeDeclarations] !localMap ![os funcDeclarations] ![os schedulerDeclarations] ![os transDeclarations] ![os backendDeclarations]];
    foreach transitions do
      # check the states exist
      [td hasState !sourceState !osWithLocals];
      [td hasState !destinationState !osWithLocals];
      @statementList verifiedList [emptyList];
      foreach statements do
        @sdmlStatement verifiedStatement := [statement sdmlStatement !osWithLocals !emptylstring[]];
        verifiedList += !verifiedStatement;
      end foreach;
      verifiedTransitions += !sourceState !destinationState !verifiedList;
    end foreach;
    result := [@transDeclaration new !name !taskType !taskName !verifiedTransitions];
  else
    error taskType: "Task type expected": result;
  end cast;
end reader;

#---------------------------------------------------------------------------*
# verify a function declaration
#
reader @funcDeclaration verify
  ??@os os
  ->@funcDeclaration result
:
  # build a variable map with the arguments, the local variables and the function name
  @varDeclarationMap localVariables := locals;
  foreach arguments do
    @varDeclaration arg := [@builtInVar new !name !type !rwAccess[]];
    [!?localVariables putData !name !arg];
  end foreach;
  
  # result variable of the function has the name of the function
  [!?localVariables putData !name ![@builtInVar new !name !type !rwAccess[]]];
  
  # verify the statements of the function
  @os osWithLocals := [@os new ![os name] ![os typeDeclarations] !localVariables ![os funcDeclarations] ![os schedulerDeclarations] ![os transDeclarations] ![os backendDeclarations]];
  @statementList verifiedStatements [emptyList];
  foreach statements do
    @sdmlStatement verifiedStatement := [statement sdmlStatement !osWithLocals !emptylstring[]];
  end foreach;
  
  result := [@funcDeclaration new !name !type !arguments !locals !verifiedStatements];
end reader;

#-----------------------------------------------------------------------------
# 
#-----------------------------------------------------------------------------
reader @backendDeclaration verify
  ??@os os
  ->@backendDeclaration result
:
  @varDeclarationMap localVariables := [@varDeclarationMap mapWithMapToOverride ![os varDeclarations]];
  foreach arguments do
#    log type;
    @varDeclaration arg := [type create !name ![os typeDeclarations]];
    [!?localVariables putData !name !arg];
  end foreach;
  
  @keyedStatementMap verifiedKeyedStatements [emptyMap];
  @os osWithLocals := [@os new ![os name] ![os typeDeclarations] !localVariables ![os funcDeclarations] ![os schedulerDeclarations] ![os transDeclarations] ![os backendDeclarations]];
  foreach keyedStatements do
    @statementList verifiedStatements [emptyList];
    foreach statements do
      @statement verifiedStatement := [statement sdmlStatement !osWithLocals !emptylstring[]];
      verifiedStatements += !verifiedStatement;
    end foreach;
    [!?verifiedKeyedStatements putStatements !lkey !verifiedStatements];
  end foreach;
  
  foreach keyedIdentifiers do
    @sdmlType identType := [[osWithLocals varDeclarations] identifierType !identifier !osWithLocals];
  end foreach;
  
  result := [@backendDeclaration new !name !arguments !verifiedKeyedStatements !keyedIdentifiers];
end reader;

#-----------------------------------------------------------------------------
# Create a variable of the corresponding type
#-----------------------------------------------------------------------------
reader @sdmlType create
  ??@lstring varName
  ??@typeDeclarationMap unused types
  ->@varDeclaration var
:
  error varName: "cannot create a variable of this type": var;
end reader;
  
override reader @sdmlBasicType create
  ??@lstring varName
  ??@typeDeclarationMap unused types
  ->@varDeclaration var
:
  var := [@builtInVar new !varName !selfcopy !rwAccess[]];
end reader;

override reader @sdmlCustom create
  ??@lstring varName
  ??@typeDeclarationMap types
  ->@varDeclaration var
:
  @typeDeclaration declaration;
  [types getTaskType !name ?declaration];
  cast declaration:
  when == @taskDeclaration do
    var := [@refVar new !varName ![@sdmlTaskRef new !name] !rwAccess[]];
  when == @cpuDeclaration do
    var := [@refVar new !varName ![@sdmlCpuRef new !name] !rwAccess[]];
  else
    error varName: "unexpected type":var;
  end cast;
end reader;

end semantics;