semantics sdml_types:

import "utilities.gSemantics";

abstract class @sdmlType {}
class @sdmlNone extends @sdmlType {}
class @sdmlBasicType extends @sdmlType {}
class @sdmlInteger extends @sdmlBasicType {}
class @sdmlUnsigned extends @sdmlBasicType {}
class @sdmlBool extends @sdmlBasicType {}
class @sdmlTimer extends @sdmlBasicType {}

class @sdmlCustom extends @sdmlBasicType { @lstring name; }

class @sdmlTaskRef extends @sdmlCustom {}
class @sdmlCpuRef extends @sdmlCustom {}

class @sdmlTaskContainer extends @sdmlCustom {}
class @sdmlCpuContainer extends @sdmlCustom {}

class @sdmlCollection extends @sdmlCustom {}
class @sdmlTaskCollectionContainer extends @sdmlCollection {}
class @sdmlCpuCollectionContainer extends @sdmlCollection {}

#---------------------------------------------------------------------------*
# type comparison
#
reader @sdmlType isEqualTo
  ??@sdmlType otherType
  ->@bool result
:
  result := [selfcopy dynamicType] == [otherType dynamicType];
end reader;
  
override reader @sdmlTaskRef isEqualTo
  ??@sdmlType otherType
  ->@bool result
:
  cast otherType:
  when == @sdmlTaskRef t do result := name == [t name];
  else result := false;
  end cast;
end reader;

override reader @sdmlCpuRef isEqualTo
  ??@sdmlType otherType
  ->@bool result
:
  cast otherType:
  when == @sdmlCpuRef c do result := name == [c name];
  else result := false;
  end cast;
end reader;

override reader @sdmlTaskCollectionContainer isEqualTo
  ??@sdmlType otherType
  ->@bool result
:
  cast otherType:
  when == @sdmlTaskCollectionContainer t do result := name == [t name];
  else result := false;
  end cast;
end reader;

override reader @sdmlCpuCollectionContainer isEqualTo
  ??@sdmlType otherType
  ->@bool result
:
  cast otherType:
  when == @sdmlCpuCollectionContainer c do result := name == [c name];
  else result := false;
  end cast;
end reader;

#---------------------------------------------------------------------------*
# type containment
#
reader @sdmlType mayContain
  ??@sdmlType otherType
  ->@bool result
:
  result := [selfcopy dynamicType] == [otherType dynamicType];
end reader;
  
override reader @sdmlTaskContainer mayContain
  ??@sdmlType otherType
  ->@bool result
:
  cast otherType:
  when == @sdmlTaskRef t do result := name == [t name];
  else result := false;
  end cast;
end reader;

override reader @sdmlCpuContainer mayContain
  ??@sdmlType otherType
  ->@bool result
:
  cast otherType:
  when == @sdmlCpuRef c do result := name == [c name];
  else result := false;
  end cast;
end reader;

override reader @sdmlTaskCollectionContainer mayContain
  ??@sdmlType otherType
  ->@bool result
:
  cast otherType:
  when == @sdmlTaskRef t do result := name == [t name];
  else result := false;
  end cast;
end reader;

override reader @sdmlCpuCollectionContainer mayContain
  ??@sdmlType otherType
  ->@bool result
:
  cast otherType:
  when == @sdmlCpuRef c do result := name == [c name];
  else result := false;
  end cast;
end reader;


#---------------------------------------------------------------------------*
# type information about ordering
#
reader @sdmlType isOrdered
  ->@bool result
:
  result := false;
end reader;

override reader @sdmlInteger isOrdered
  ->@bool result
:
  result := true;
end reader;

override reader @sdmlUnsigned isOrdered
  ->@bool result
:
  result := true;
end reader;



#---------------------------------------------------------------------------*
# textual typeName
#
abstract reader @sdmlType typeName
  ->@string result;
  
override reader @sdmlNone typeName
  ->@string result
:
  result := "";
end reader;

override reader @sdmlBasicType typeName
  ->@string result
:
  error here: "@sdmlBasicType has no type name" :result;
end reader;

override reader @sdmlCustom typeName
  ->@string result
:
  result := [name string];
end reader;

override reader @sdmlInteger typeName
  ->@string result
:
  result := "int";
end reader;

override reader @sdmlUnsigned typeName
  ->@string result
:
  result := "unsigned";
end reader;

override reader @sdmlBool typeName
  ->@string result
:
  result := "bool";
end reader;

override reader @sdmlTimer typeName
  ->@string result
:
  result := "timer";
end reader;

#---------------------------------------------------------------------------*
# textual lTypeName
#
abstract reader @sdmlType lTypeName
  ->@lstring result;
  
override reader @sdmlNone lTypeName
  ->@lstring result
:
  result := emptylstring[];
end reader;

override reader @sdmlBasicType lTypeName
  ->@lstring result
:
  error here: "@sdmlBasicType has no type name" :result;
end reader;

override reader @sdmlCustom lTypeName
  ->@lstring result
:
  result := name;
end reader;

override reader @sdmlInteger lTypeName
  ->@lstring result
:
  result := [@lstring new !"int" !here];
end reader;

override reader @sdmlUnsigned lTypeName
  ->@lstring result
:
  result := [@lstring new !"unsigned" !here];
end reader;

override reader @sdmlBool lTypeName
  ->@lstring result
:
  result := [@lstring new !"bool" !here];
end reader;

override reader @sdmlTimer lTypeName
  ->@lstring result
:
  result := [@lstring new !"timer" !here];
end reader;

#---------------------------------------------------------------------------*
# isCollection reader
#
reader @sdmlType isCollection
  ->@bool result
:
  result := false;
end reader;

override reader @sdmlCollection isCollection
  ->@bool result
:
  result := true;
end reader;

end semantics;